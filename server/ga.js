// Generated by CoffeeScript 1.7.1
(function() {
  var authClient, authPromise, config, fetch, gapi, queries, rsvp;

  gapi = require("googleapis");

  rsvp = require("rsvp");

  config = require("./config");


  /*
   * generic GA util
   */

  authClient = new gapi.auth.JWT(config.ga.clientEmail, config.ga.privateKeyPath, null, [config.ga.scopeUri]);

  authPromise = new rsvp.Promise(function(resolve, reject) {
    var msg;
    if (process.env.GA_KEY_PATH == null) {
      msg = "ERROR: process.env.GA_KEY_PATH mismatch or " + process.env.GA_KEY_PATH;
      console.log(msg);
      reject(new Error(msg));
    } else {
      authClient.authorize(function(err, token) {
        console.log("WIP: OAuthing w/ GA...");
        if (err != null) {
          console.log("ERROR: OAuth, err = ", err);
          reject(err);
        } else {
          resolve(token);
          console.log("SUCCESS: server OAuthed w/ GA.");
        }
      });
    }
  });

  fetch = function(key) {
    return function() {
      var promises, query;
      query = queries[key];
      promises = [];
      query.queryObjs.forEach(function(queryObj) {
        var promise;
        promise = new rsvp.Promise(function(resolve, reject) {
          gapi.discover('analytics', 'v3').execute(function(err, client) {
            if (err != null) {
              reject(err);
            } else {
              client.analytics.data.ga.get(queryObj).withAuthClient(authClient).execute(function(err, result) {
                if (err != null) {
                  return reject(err);
                } else {
                  resolve(result);
                }
              });
            }
          });
        });
        promises.push(promise);
      });
      return rsvp.all(promises).then(query.transform);
    };
  };


  /*
   * define queries
   */

  queries = {};

  queries.users = {
    queryObjs: [
      {
        'ids': 'ga:' + config.ga.profile,
        'start-date': '2014-03-15',
        'end-date': 'yesterday',
        'metrics': 'ga:visits',
        'dimensions': 'ga:visitorType,ga:date'
      }
    ],
    transform: function(data) {
      return new rsvp.Promise(function(resolve, reject) {
        var result;
        result = data[0].rows;
        result.forEach(function(d) {
          d[0] = d[0] === 'New Visitor' ? 'N' : 'E';
          d[2] = +d[2];
        });
        resolve(result);
      });
    }
  };

  queries.commands = {
    queryObjs: [
      {
        'ids': 'ga:' + config.ga.profile,
        'start-date': '7daysAgo',
        'end-date': 'yesterday',
        'metrics': 'ga:visitors,ga:pageviews',
        'dimensions': 'ga:pagePathLevel1'
      }, {
        'ids': 'ga:' + config.ga.profile,
        'start-date': '14daysAgo',
        'end-date': '8daysAgo',
        'metrics': 'ga:visitors,ga:pageviews',
        'dimensions': 'ga:pagePathLevel1'
      }
    ],
    transform: function(data) {
      var icon, order;
      order = {
        Install: 1,
        Uninstall: 2,
        Register: 3,
        Info: 4,
        Search: 5
      };
      icon = {
        Install: 'download',
        Uninstall: 'trash-o',
        Register: 'pencil',
        Info: 'info',
        Search: 'search'
      };
      return new rsvp.Promise(function(resolve, reject) {
        var commandCheck, current, getMetric, getValue, prior, result, _transform;
        current = data[0].rows;
        prior = data[1].rows;
        _transform = function(d) {
          var command;
          command = d[0].replace(/\//g, '');
          command = command.charAt(0).toUpperCase() + command.slice(1);
          d[0] = command;
          d[1] = +d[1];
          d[2] = +d[2];
        };
        current.forEach(_transform);
        prior.forEach(_transform);
        commandCheck = function(d) {
          return d[0].indexOf("ed") === -1 && d[0] !== "Searched";
        };
        result = current.filter(function(d) {
          return commandCheck(d);
        }).map(function(d) {
          return {
            command: d[0],
            order: order[d[0]],
            icon: icon[d[0]],
            metrics: [
              {
                type: 'users',
                order: 1,
                current: d[1]
              }, {
                type: 'uses',
                order: 2,
                current: d[2]
              }
            ]
          };
        });
        getValue = function(command, period, ed, valueType) {
          var error, i;
          ed = ed ? 'ed' : '';
          i = valueType === 'users' ? 1 : 2;
          try {
            return period.filter(function(d) {
              return d[0] === command.command + ed;
            })[0][i];
          } catch (_error) {
            error = _error;
            return 0;
          }
        };
        getMetric = function(command, type) {
          return command.metrics.filter(function(d) {
            return d.type === type;
          });
        };
        result.forEach(function(command) {
          if (["Install", "Uninstall", "Register", "Unregister"].indexOf(command.command) !== -1) {
            command.metrics.push({
              type: 'packages',
              order: 3,
              current: getValue(command, current, true, 'packages')
            });
          }
          command.metrics.forEach(function(metric) {
            metric.prior = getValue(command, prior, (metric.type === 'packages' ? true : false), metric.type);
            metric.delta = metric.current / metric.prior - 1;
          });
        });
        return resolve(result);
      });
    }
  };

  module.exports = {
    validQueryTypes: Object.keys(queries),
    queries: queries,
    authPromise: authPromise,
    fetch: fetch
  };

}).call(this);

//# sourceMappingURL=ga.map
